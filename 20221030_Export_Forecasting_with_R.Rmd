---
title: "Soybean Export Forecast with R"
author: "Felipe Tufaile, Vinicius de Camargo, Helena Funari, Rodrigo Zamengo"
date: "`r Sys.Date()`"
output: html_document
---

### Summary

This document aims to study the time series of soybean exports with the aid of the R language and packages available for time series analysis for the mentioned programming language. The study will focus only on the Midwest region of Brazil in order to diminish the impact of different seasonal patterns in the soybean production cycle in different regions of Brazil. The study will, therefore, cover the analysis of its components (trend, seasonality and noise), forecasting export volume for future months using time series models like **sarima** and **prophet**, the implementation of techniques for adjusting the time series as well as any other observation on the characteristics of the time series that might be relevant.


```{r configs, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, include = TRUE, message = FALSE)
```

### Loading libraries

```{r libraries}

## Set working directory
#setwd("~/Insper/Commodity_Export_Forecast")

library(dplyr)
library(tidyverse)
library(ggthemes)
library(fpp3)
library(forecast)
library(gridExtra)
library(ggpubr)
library(tseries)
```

### Defining Functions

The following codes aims to define some function that will help plotting graphs and analyzing the time series through this study.

```{r functions}

## Creating function for adding time series to ggplots
add_serie <- function(data, xdata, ydata, name, color, text_position, labels) {

  list(geom_line(data=data, aes(x=.data[[xdata]], y=.data[[ydata]], color=name), linetype="solid", alpha=0.8),
       geom_text(data=data, aes(x=.data[[xdata]], y=.data[[ydata]], label=.data[[labels]]),
                 colour = color,
                 size=2.5, 
                 vjust=ifelse(text_position=="Above", -1, 2), hjust=0.5))
}

## Defining custom x-labels for time series plot without lag
time_series_xlabels <- function(){
  scale_x_date(breaks=seq(from=as.Date("1997-01-01"), to=as.Date("2022-01-01"), by = "12 month"), 
               date_label = "%b\n%y", expand=expansion(mult = c(0.02, 0.02)))
}

## Defining custom themes
time_series_theme <- function(){
  theme_hc() +
  theme(plot.background = element_rect(fill = "white"),
        panel.background = element_rect(fill = "white"),
        panel.grid.major.y = element_line(colour = '#E6E7E8'),
        panel.grid.minor.y = element_line(colour = '#E6E7E8'),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        axis.line.y = element_line(colour = '#000000'),
        axis.line.x = element_line(colour = '#000000'),
        axis.text.y = element_text(colour = '#000000', size=8),
        axis.ticks.y = element_line(colour = '#000000'),
        axis.title.y = element_text(colour = '#000000', size=8),
        legend.position = "bottom",
        plot.title = element_text(colour = "#000000", size=14),
        plot.subtitle = element_text(colour = '#585858', size=12),
        text = element_text(colour = '#585858', size=9),
        axis.text = element_text(colour = '#585858', size=8))
  }
```


### Data Loading

The database used in this study was taken from the open data platform of the ministry of agriculture. The platform has import and export information for various agribusiness products aggregated by month, year, country, state, product, among other groupings. The Information is available at the following link: https://indicadores.agricultura.gov.br/agrostat/index.htm.
As mentioned in the beggining of this study, the dataset will be filtered in order to consider only soy bean volume exported from the Midwest of Brazil.

```{r loading_dataset}
# Reading export dataset
export <- read_csv("https://raw.githubusercontent.com/FelipeTufaile/Commodity_Export_Forecast/main/export_database.csv")

# Selecting soy bean production in midwest
midwest_soybean <- export %>% 
  filter(produto == 'COMPLEXO SOJA' & regiao == 'CENTRO-OESTE' & ref_ano >= 2000 & ref_ano <= 2021) %>%
  group_by(ref_date_fmd) %>%
  summarize(vl_mm_ton = sum(massa_exportada_kg)/10^9)

```


### Plotting time-series

The following chart shows the mass (millions of ton) of soy bean exported from January of 2000 to December of 2021. In order to account only for complete years, the year of 2022 was left out of this plot, but will be used later on this document.
Looking at the plot, it can be noticed that the time series seems to have a well defined seasonal pattern, but with increasing variance along the years. That is, the series denotes a heteroskedastic behavior. Given this fact, a Box Cox transformation could help make the data more 'normally’ distributed and thus help
stabilize its variance. With this transformation, forecasting can be substantially simpler. For that reason it will also be studied the Box-Cox transformed time series.
 

```{r plotting_series_01, out.width="100%"}
## Plotting
plot <- ggplot() +
  add_serie(data=midwest_soybean %>% mutate(labels = ""), 
            xdata="ref_date_fmd", 
            ydata="vl_mm_ton", 
            name='Soy Bean Export', 
            color="#C4161C", 
            text_position="Above", 
            labels="labels") +
  scale_color_manual(name="", breaks=c('Soy Bean Export'), values=c('#C4161C')) +
  time_series_xlabels() +
  scale_y_continuous(limits=c(0, 9), breaks=seq(0, 9, 1), minor_breaks=seq(0, 9, 0.5)) +
  labs(x = "", 
       y = "Soy Bean Export (MM Ton)",
       title="Soy Bean Export in Midwest of Brazil from Jan-2000 to Dec-2021",
       subtitle="") +
  time_series_theme()

plot
```


### Applying a boxcox transformation on the time-series

A Box-Cox transformation is a power transform function that is used to stabilize variance and make the data more "normally" distributed, which may improve the performance in forecasting for some time-series models. The one-parameter Box-Cox transformation is defined as:   

\begin{align*}
y_{i}^{(\lambda)} = \frac{y_{i}^{(\lambda)}-1}{\lambda} \text{ if } \lambda \ne 0 \\
y_{i}^{(\lambda)} = \ln(y_{i}) \text{ if } \lambda = 0
\end{align*}

Applying the transformation on the original time-series yields:

```{r boxcox, out.width="100%"}
## Calculating boxcox transformation on vl_mm_ton
boxcox_transform <- BoxCox(midwest_soybean$vl_mm_ton, lambda = "auto")

## Creating a new tibble with the transformed vl_mm_ton value
midwest_soybean_boxcox <- tibble(ref_date_fmd = midwest_soybean$ref_date_fmd,
                                 vl_mm_ton_boxcox = c(boxcox_transform))

## Plotting
plot <- ggplot() +
  add_serie(data=midwest_soybean_boxcox %>% mutate(labels = ""), 
            xdata="ref_date_fmd", 
            ydata="vl_mm_ton_boxcox", 
            name="Soy Bean Export", 
            color="#C4161C", 
            text_position="Above", 
            labels="labels") +
  scale_color_manual(name="", breaks=c('Soy Bean Export'), values=c('#C4161C')) +
  time_series_xlabels() +
  scale_y_continuous(limits=c(-3, 3), breaks=seq(-3, 3, 1), minor_breaks=seq(-3, 3, 0.5)) +
  labs(x = "", 
       y = "Soy Bean Export (MM Ton)",
       title=paste('Soy Bean Export in Midwest of Brazil | Box-Cox transformation with lambda=', round(attributes(boxcox_transform)$lambda,2)),
       subtitle="") +
  time_series_theme()

plot
```

It can be seem that the transformation helped to reduce the change in variance over time, although it seems that there is still a difference in the variance of recent years and older years. In order to validate if the transformation in fact helped to give a more normal-like distribution, the following chart shows a qq plot of the original and Box-Cox transformed series. It is evident that the transformed series is more adherent to the straight line in the chart, meaning the transformation has improved normality.  

```{r qqplot, out.width="100%"}
df_hist = rbind(tibble(vl_mm_ton = as.double(midwest_soybean$vl_mm_ton), type = "Original"), 
                tibble(vl_mm_ton = as.double(midwest_soybean_boxcox$vl_mm_ton_boxcox), type = "BoxCox"))
ggplot(df_hist, aes(sample = vl_mm_ton)) +
geom_qq() +
geom_qq_line() +
facet_grid(type ~ ., scales = "free_y") +
ggtitle("QQ plot: Original versus transformed time series", "BoxCox transform improved normality")

```


### Time Series Analysis and ACF / PACF plots

Analyzing the time series in the above figures it seems that both time series, original and transformed, have a stochastic trend since there seems to be some randomness building up over time. In order to confirm that observation it will be applied a **ADF** (Augmented Dicker-Fuller) test to check if there is unit-roots present in the series.

**ADF test on original time series**
```{r adf_test_original}
tseries::adf.test(midwest_soybean$vl_mm_ton,
                  alternative = c("stationary", "explosive"), 
                  k = trunc((length(midwest_soybean$vl_mm_ton)-1)^(1/3)))
```

**ADF test on transformed time series**
```{r adf_test_transformed}
tseries::adf.test(midwest_soybean_boxcox$vl_mm_ton_boxcox,
                  alternative = c("stationary", "explosive"), 
                  k = trunc((length(midwest_soybean_boxcox$vl_mm_ton_boxcox)-1)^(1/3)))
```

The null hypothesis of the **ADF** assumes that there is an unit root in the time series (therefore the series is non-stationary), whereas the alternate hypothesis, as configured in the function above, assumes that the series are stationary. Since the p-values obtained for both tests are low (less than 0.05) the null hypothesis is rejected indicating that the series, original and transformed, are stationary. However, as mentioned by Robert Hyndman in his book, different unit root tests are available, which are based on different assumptions and may lead to conflicting answers (Hyndman, 2021). In the book, Hyndman suggests the Kwiatkowski-Phillips-Schmidt-Shin (**KPSS**) test (Kwiatkowski et al., 1992) as an alternative. As indicated in the reference mentioned, the **KPSS** test assumes that the data is stationary as the null hypothesis. Therefore, small p-values suggest that the data has an unit root and that differencing is required. Applying the **KPSS** yields:

**KPSS test on original time series**
```{r kpss_test_original}
## Building time series object on exporting data
midwest_soybean_tsibble <- midwest_soybean %>%
    select(ref_date_fmd, vl_mm_ton) %>%
    dplyr::mutate(ref_date_fmd = tsibble::yearmonth(ref_date_fmd)) %>%
    tsibble::as_tsibble(index=ref_date_fmd)

## Performing KPSS test
midwest_soybean_tsibble %>%
  fabletools::features(.tbl=., .var=vl_mm_ton, features=list(unitroot_kpss, unitroot_ndiffs))
```

**KPSS test on transformed time series**
```{r kpss_test_transformed}
## Building time series object on exporting data
midwest_soybean_boxcox_tsibble <- midwest_soybean_boxcox %>%
    select(ref_date_fmd, vl_mm_ton_boxcox) %>%
    dplyr::mutate(ref_date_fmd = tsibble::yearmonth(ref_date_fmd)) %>%
    tsibble::as_tsibble(index=ref_date_fmd)

## Performing KPSS test
midwest_soybean_boxcox_tsibble %>%
  fabletools::features(.tbl=., .var=vl_mm_ton_boxcox, features=list(unitroot_kpss, unitroot_ndiffs))
```

Since the p-value obtained with the **KPSS** test is low for both series (less than 0.05), the null hypothesis is rejected suggesting that both time series are non-stationary, differently from the conclusion obtained with the **ADF** test. Furthermore, the **KPSS** test indicates that one differencing is required for each series. Since that intuitively the guess was that the series had stochastic trend and that the **KPSS** test suggested no evidence of stationarity, the series will be considered to have stochastic trend and, therefore, to be non-stationary. For that reason, it will be applied one-differencing to each series in order to remove the unit root.

**Differencing the time-series**

```{r}
## Building a time series object on the exporting data with one differencing on exported amount
dt1_midwest_soybean_tsibble <- midwest_soybean %>%
    dplyr::select(ref_date_fmd, vl_mm_ton) %>%
    dplyr::mutate(vl_mm_ton_dt1 = difference(vl_mm_ton,12)) %>%
    dplyr::select(-vl_mm_ton) %>%
    dplyr::mutate(ref_date_fmd = tsibble::yearmonth(ref_date_fmd)) %>%
    tsibble::as_tsibble(index=ref_date_fmd)

## Building a time series object on the transformed exporting data with one differencing on exported amount
dt1_midwest_soybean_boxcox_tsibble <- midwest_soybean_boxcox %>%
    dplyr::select(ref_date_fmd, vl_mm_ton_boxcox) %>%
    dplyr::mutate(vl_mm_ton_boxcox_dt1 = difference(vl_mm_ton_boxcox,12)) %>%
    dplyr::select(-vl_mm_ton_boxcox) %>%
    dplyr::mutate(ref_date_fmd = tsibble::yearmonth(ref_date_fmd)) %>%
    tsibble::as_tsibble(index=ref_date_fmd)
```


**Plotting the Auto-Correlation and Partial Auto-Correlation functions**  

```{r acf_pacf_original, out.width="100%"}
## Plotting the auto-correlation function and partial auto-correlation function for the export time series with one difference
dt1_midwest_soybean_tsibble %>%
  gg_tsdisplay(vl_mm_ton_dt1, plot_type='partial')
```

```{r acf_pacf_transformed, out.width="100%"}
## Plotting the auto-correlation function and partial auto-correlation function for the export time series with one difference
dt1_midwest_soybean_boxcox_tsibble %>%
  gg_tsdisplay(vl_mm_ton_boxcox_dt1, plot_type='partial')
```

The **ACF** and **PACF** plots for both series, original and transformed, look very similar. Therefore, the highlight mentioned in the sequence are valid for both series. First, it is noticeable that the ACF peaks in seasonal lags multiples of 12, which are significantly different from 0. That suggest that the **P** term of a SARIMA model would be equal to 12, **P = 12**. Furthermore, the **ACF** and **PACF** for lag 1 are also greater than 0, suggesting that good candidate models would have **p = 1** and / or **q = 1**.\
Given the observations made in the previous paragraph, good suggestion of models for modeling the time series of soy bean export in the Midwest of Brazil would be an **ARIMA(1,1,0)(0,1,0)[12]** and an **ARIMA(0,1,1)(0,1,0)[12]**. This models, along the models suggest by the **stepwise** and **search** algorithms from **fable** package will be verified in upcoming chapters.


## Studying seasonality

```{r cartesian_seasonal_chart, out.width="100%"}
## Plotting monthly seasonal chart using library feasts | Cartesian view
midwest_soybean_tsibble %>% 
  feasts::gg_season(y=vl_mm_ton)
```

```{r polar_seasonal_chart, out.width="100%"}
## Plotting monthly seasonal chart using library feasts | Polar view
midwest_soybean_tsibble %>% 
  feasts::gg_season(y=vl_mm_ton, polar=TRUE)
```

```{r time_series_decomposition, out.width="100%"}
## Using STL model from fpp3
dcmp <- midwest_soybean_tsibble %>%
  model(stl = STL(vl_mm_ton))

components(dcmp) %>% autoplot()
```

```{r time_series_boxcox_time_series, out.width="100%"}
## Building time series object on exporting data
midwest_soybean_boxcox_tsibble <- midwest_soybean_boxcox %>%
    select(ref_date_fmd, vl_mm_ton_boxcox) %>%
    dplyr::mutate(ref_date_fmd = tsibble::yearmonth(ref_date_fmd)) %>%
    tsibble::as_tsibble(index=ref_date_fmd)

## Using STL model from fpp3
dcmp_boxcox <- midwest_soybean_boxcox_tsibble %>%
  model(stl = STL(vl_mm_ton_boxcox))

components(dcmp_boxcox) %>% autoplot()
```


```{r comparing_datasets, out.width="100%"}
## Original dataset
plot_original <- midwest_soybean_tsibble %>%
  autoplot(vl_mm_ton) +
  geom_smooth() +
  ggtitle("Original scale")

## Transformed dataset
plot_boxcox <- midwest_soybean_boxcox_tsibble %>%
  autoplot(vl_mm_ton_boxcox) +
  geom_smooth() +
  ggtitle(paste("Box Cox with lambda = ", round(attributes(boxcox_transform)$lambda,2)))

## Comparision
plot <- ggarrange(plot_original, plot_boxcox, ncol=2, nrow=1, widths=c(1,1), common.legend = FALSE)

annotate_figure(plot, top=text_grob("Soy Bean Export in Midwest of Brazil", 
                                    color="#000000", 
                                    size=14, 
                                    x=unit(0.5, "lines"), 
                                    y=unit(0, "lines"), 
                                    just="left", 
                                    hjust=0, 
                                    vjust=0))

```
```{r}
y <- midwest_soybean_tsibble$vl_mm_ton

```


```{r}
library(forecast)
fit1 = Arima(y,order=c(2,0,0),seasonal=list(order=c(2,1,2),period=12),method="ML")
fit2 = Arima(y,order=c(1,0,0),seasonal=list(order=c(1,1,0),period=12),method="ML")
fit3 = Arima(y,order=c(0,0,2),seasonal=list(order=c(1,1,0),period=12),method="ML")
fit_auto <- auto.arima(midwest_soybean$vl_mm_ton)
fit_auto_bc <- auto.arima(midwest_soybean$vl_mm_ton, lambda = 0.14)

aic  = c(fit1$aic,fit2$aic,fit3$aic,fit_auto$aic,fit_auto_bc$aic)
aicc = c(fit1$aicc,fit2$aicc,fit3$aicc,fit_auto$aicc,fit_auto_bc$aicc)
bic  = c(fit1$bic,fit2$bic,fit3$bic,fit_auto$bic,fit_auto_bc$bic)
cbind(aic,aicc,bic)




```
```{r}
res <- fit1$residuals
par(mfrow=c(1,1))
Acf(res,main="",xlab="")
Box.test(res, lag=24, fitdf=1, type="Ljung")
```


```{r}
plot(forecast(fit1,h=12))
```
#Backtest

```{r}

```


### Bibliography

[1] Hyndman, R.J., & Athanasopoulos, G. (2021) Forecasting: principles and practice, 3rd edition, OTexts: Melbourne, Australia. OTexts.com/fpp3. Accessed on 2022-11-01.

[2] Indicadores Agricultura, Ministério da Agrigultura Brasileiro. https://indicadores.agricultura.gov.br/agrostat/index.htm. Acessed on 2022-10-29.

- https://harlecin.netlify.app/post/box-cox-and-other-transformations/

